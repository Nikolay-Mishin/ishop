### [[Перевод] Магические методы в PHP](https://habr.com/ru/post/228951/)

Если Вы когда-нибудь изучали PHP-код открытых проектов, то вы могли встречать методы, начинающиеся с двойного подчеркивания. Это и есть те самые магические методы, с помощью которых вы сможете определить поведение вашего объекта при различных манипуляциях с его экземпляром.

Предполагаю, что вы уже сталкивались с некоторыми из них, ведь существуют довольно распространенные методы, и тем не менее, я считаю, что компетентному программисту PHP необходимо уверенное владение всеми возможностями языка.
Я думаю, это можно считать, своего рода, отправной точкой в мир Магических методов.

#### Приступая к изучению

Когда я сам изучал этот материал, я использовал всевозможные учебники и статьи, в которых излагались довольно глупые или вообще бесполезные примеры. Я считаю, что для того чтобы понять что-то нужно попробовать это в контексте реальной задачи. Именно с этого мы и начнем.

Представим себе, что мы хотим получать все твиты, при помощи Tweeter Api. Мы получаем JSON всех твитов текущего пользователя и хотим превратить каждый твит в объект с методами, которые позволят проводить определенные операции.

Ниже, я представил базовый класс Tweet:

```php
class Tweet {
 
}
```

Теперь, когда мы создали объект, мы можем приступать к изучению самих методов. (Прим. переводчика — некоторые конструкции будут иногда опускаться, чтобы акцентировать на роли и возможностях каждого метода)

#### Конструкторы и Деструкторы

Пожалуй, одним из самых наиболее распространенных магических методов является конструктор ( __construct() ). Если вы достаточно внимательно следили за созданием приложения Cribbb в моем блоге, вы достаточно осведомлены об этом методе.

Метод __construct() автоматически вызывается, когда был создан экземпляр объекта. В нем вы можете задать начальные свойства объекта или установить зависимости.

###### Пример использования:

```php
public function __construct($id, $text)
{
  $this->id = $id;
  $this->text = $text;
}
 
$tweet = new Tweet(123, 'Hello world');
```

Когда мы создаем экземпляр класса Tweet, мы можем передать параметры, которые поступят в метод __construct(). Из примера выше, вы можете видеть, что мы не вызываем этот метод и не должны вызывать — он вызывается автоматически.

Со временем у вас возникнет необходимость расширение класса путем его наследования. Иногда родительский класс так же имеет метод __construct(), который совершает определенные действия, таким образом чтобы не потерять функционал класса-родителя, нужно вызвать и его конструктор.

```php
class Entity {
  protected $meta;
  public function __construct(array $meta)
  {
	$this->meta = $meta;
  }
 
}
 
class Tweet extends Entity {
  protected $id;
  protected $text;
  public function __construct($id, $text, array $meta)
  {
	$this->id = $id;
	$this->text = $text;
	parent::__construct($meta);
  }
}
```

При попытке удалить объект будет вызван метод __destruct(). Опять же, по аналогии с конструктором — это не то что нужно вызывать, ведь PHP все сделает за вас. Этот метод позволит вам очистить все, что вы использовали в объекте, например соединение с базой данных.

```php
public function __destruct()
{
  $this->connection->destroy();
}
```

Если быть честным, то большую часть метода __destruct(), изложенного выше я скрыл от вас. PHP на самом деле не из тех языков, где процесс будет существовать достаточно длительное время, так что я не думаю, что у вас будет что-либо для чего мог бы понадобиться деструктор. Сам по себе жизненный цикл запроса в PHP настолько мал, что от данного метода будет скорее больше хлопот, чем пользы.

#### Геттеры и сеттеры

Когда вы работаете с обьектами в PHP, вам бы очень хотелось обращаться к свойствам объекта как-то так:

```php
$tweet = new Tweet(123, 'hello world');
echo $tweet->text; // 'hello world'
```

Однако, если у свойства text установлен модификатор доступа protected, то такое обращение вызовет ошибку.
Магический метод __get() будет отлавливать обращения к любым не публичным свойствам.

```php
public function __get($property)
{
  if (property_exists($this, $property)) {
	return $this->$property;
  }
}
```

Метод __get() приминает имя свойства, к которому вы обращаетесь, в качестве аргумента. В приведенном выше примере сначала проверяется существование свойства в объекте и если оно существует, то возвращается его значение.

Как и в примерах выше — вы не должны вызывать этот метод напрямую, PHP будет вызывать его каждый раз, при попытке получения доступа к не публичным свойствам класса.

В обратной ситуации — если вы попытаетесь установить значение свойства, которое не является публичным — вы получите ошибку. И опять же, в PHP есть свой метод, который будет вызван при попытке установить в не публичное поле какое-либо значение. Данный метод принимает 2 параметра в качестве аргументов — свойство, в которое хотели записать значение, и само значение.

Если вы хотите использовать данный метод, ваш класс получит свойство, на подобии этого:

```php
public function __set($property, $value)
{
  if (property_exists($this, $property)) {
	$this->$property = $value;
  }
}
 
$tweet->text = 'Setting up my twttr';
echo $tweet->text; // 'Setting up my twttr'
```

В приведенных выше примерах я показал как можно получить или установить значения свойств, не имеющих модификатор доступа public. Однако работа с данными магическими методами не всегда будет лучшей идеей. Гораздо лучше иметь множество методов для получения и записи свойств, так как в этом случае они формируют определенный API и это означает, что при изменении способа хранения или обработки ваш код не будет сломан.

Впрочем, вы все равно иногда будете встречать методы __get() и __set(), которые принято называть геттерами и сеттерами соотвественно. Это довольно хорошее решение, если вы решили изменить какое-либо значение или добавить немножко бизнес-логики.

#### Проверка свойства на существование

Если вы знакомы с PHP, вы скорее всего знаете о существовании функции isset(), которую обычно применяют при работе с массивами. Вы так же можете использовать эту функцию, для того чтобы понять — задано свойство в обьекте или нет. Вы сможете определить магический метод __isset(), для того чтобы можно проверять не только общедоступные свойства, но и другие.

```php
public function  __isset($property)
{
  return isset($this->$property);
}
 
isset($tweet->text); // true
```

Как вы видите выше, __isset() метод отслеживает вызов функции на проверку существования и получает в качестве аргумента — название свойства. В свою очередь, в методе вы можете использовать функцию isset(), для проверки существования.

#### Очистка переменной

По аналогии с функцией isset(), функция unset() обычно используется при работе с массивами. Опять же, вы можете использовать функцию unset() для того чтобы очистить значение не публичного свойства. Чтобы применить данный метод на не публичные свойства, вам понадобиться метод __unset(), который будет отслеживать попытки очистить не публичный свойства класса.

```php
public function __unset($property)
{
  unset($this->$property);
}
```

#### Приведение к строке

Метод __toString() позволит вам определить логику работы вашего приложения, при попытке привести обьект к типу строке.

###### Например:

```php
public function __toString()
{
  return $this->text;
}
 
$tweet = new Tweet(1, 'hello world');
echo $tweet; // 'hello world'
```

Можно сказать, что когда вы пытаетесь обратиться к обьекту, как к строке, например при использовании echo, обьект будет возвращен так, как вы определите в __toString() методе.

Хорошей иллюстрацией в данном случае может случить Eloquent Models из фреймворка Laravel. При попытке приведения обьекта к строке вы получите json. Если вы хотите увидеть как Laravel это делает, рекомендую обратиться к [исходному коду](https://github.com/laravel/framework/blob/master/src/Illuminate/Database/Eloquent/Model.php#L3009).

#### Сон и пробуждение

Функция сериализации ( serialize() ), является довольно распространенным способом хранения обьекта. Например, если бы вы хотели сохранить обьект в базе данных, для начала вы должны были бы его сериализовать, затем сохранить, а когда бы он вам потребовался снова, вы должны были бы его получить и десериализовать ( unserialise() ).

Метод __sleep(), позволяет определить какие свойства должны быть сохранены. Если бы мы к примеру, не хотели сохранять какие-либо связи или внешние ресурсы.

Представим себе, что когда мы создаем обьект, мы хотим определить механизм его сохранения.

```php
$tweet = new Tweet(123, 'Hello world', new PDO ('mysql:host=localhost;dbname=twttr', 'root'));
```

Когда мы готовим к сохранению обьект, нам естественно не нужно сохранить подключение к базе данных, ведь в будущем это будет бессмысленно.
Поэтому в методе __sleep() мы определим массив свойств, которые должны быть сохранены.

```php
public function __sleep()
{
  return array('id', 'text');
}
```

А после того как настанет время для пробуждения обьекта, нам могут понадобиться все то, что мы не сохранили при сериализации. В конкретном примере нам нужно установить соединение с базой данных. Это можно сделать, при помощи магического метода __wakeup().

```php
public function __wakeup()
{
  $this->storage->connect();
}
```

#### Вызов методов

Магический метод __call(), будет перехватывать все попытки вызовов методов, не являющихся публичными. Например, у вас может быть массив данных, которые вы хотите изменить:

```php
class Tweet {
  protected $id;
  protected $text;
  protected $meta;
 
  public function __construct($id, $text, array $meta)
  {
	$this->id = $id;
	$this->text = $text;
	$this->meta = $meta;
  }
 
  protected function retweet()
  {
	$this->meta['retweets']++;
  }
 
  protected function favourite()
  {
	$this->meta['favourites']++;
  }
 
  public function __get($property)
  {
	var_dump($this->$property);
  }
 
  public function __call($method, $parameters)
  {
	if (in_array($method, array('retweet', 'favourite')))
	{
	  return call_user_func_array(array($this, $method), $parameters);
	}
  }
}
 
$tweet = new Tweet(123, 'hello world', array('retweets' => 23, 'favourites' => 17));
 
$tweet->retweet();
$tweet->meta; // array(2) { ["retweets"]=> int(24) ["favourites"]=> int(17) }
```

Еще один типичный пример это использование другого публичного API в своем обьекте.

```php
class Location {
	protected $latitude;
	protected $longitude;
	
	public function __construct($latitude, $longitude)
	{
		$this->latitude = $latitude;
		$this->longitude = $longitude;
	}

	public function getLocation()
	{
		return array(
			'latitude' => $this->latitude,
			'longitude' => $this->longitude,
		);
	}
}
 
class Tweet {
	protected $id;
	protected $text;
	protected $location;

	public function __construct($id, $text, Location $location)
	{
		$this->id = $id;
		$this->text = $text;
		$this->location = $location;
	}
	public function  __call($method, $parameters)
	{
		if(method_exists($this->location, $method))
		{
		  return call_user_func_array(array($this->location, $method), $parameters);
		}
	}
}
 
$location = new Location('37.7821120598956', '-122.400612831116');
$tweet = new Tweet(123, 'Hello world', $location);
 
var_dump($tweet->getLocation()); // array(2) { ["latitude"]=> string(16) "37.7821120598956" ["longitude"]=> string(17) "-122.400612831116" }
```

В приведенном выше примере, мы можем вызвать метод getLocation на обьекте класса Tweet, но на самом деле мы его делегируем классу Location.
Если вы пытаетесь вызвать статический метод, вы можете так же воспользоваться __callStatic() магическим методом. Главное помните, что работает он лишь при вызове статичных методов.

#### Клонирование

Когда вы создаете копию объекта в PHP, по факту в переменную записывается не новый объект, а идентификатор, ссылающийся на оригинальный обьект. То есть любое изменение в ссылающимся объекте влечет за собой изменение первоначального объекта, однако удаление любого из объектов не повлияет на существование других:

```php
$sheep1 = new stdClass;
$sheep2 = $sheep1;
 
$sheep2->name = "Polly";
$sheep1->name = "Dolly";
 
echo $sheep1->name; // Dolly
echo $sheep2->name; // Dolly


$a = new StdClass;
$b = $a;
$a = null;
var_dump($b); // object(stdClass)#1 (0) {  }


Для того чтобы создать копию обьекта вам следуюет использовать ключевое слово clone.

$sheep1 = new stdClass;
$sheep2 = clone $sheep1;
 
$sheep2->name = "Polly";
$sheep1->name = "Dolly";
 
echo $sheep1->name; // Dolly
echo $sheep2->name; // Polly
```

Однако, если у нас есть несколько связанных обьектов, зависимости, которые находятся в них, так же будут скопированы.

```php
class Notification {
  protected $read = false;
 
  public function markAsRead()
  {
	$this->read = true;
  }
 
  public function isRead()
  {
	return $this->read == true;
  }
 
}
 
class Tweet {
  protected $id;
  protected $text;
  protected $notification;
 
  public function __construct($id, $text, Notification $notification)
  {
	$this->id = $id;
	$this->text = $text;
	$this->notification = $notification;
  }
 
  public function  __call($method, $parameters)
  {
	if(method_exists($this->notification, $method))
	{
	  return call_user_func_array(array($this->notification, $method), $parameters);
	}
  }
}
 
$tweet1 = new Tweet(123, 'Hello world', new Notification);
$tweet2 = clone $tweet1;
 
$tweet1->markAsRead();
var_dump($tweet1->isRead()); // true
var_dump($tweet2->isRead()); // true
```

Для того чтобы решить данную проблему мы можем определить метод __clone() для того чтобы определить правильное поведение:

```php
class Tweet {
 
  protected $id;
  protected $text;
  protected $notification;
 
  public function __construct($id, $text, Notification $notification)
  {
	$this->id = $id;
	$this->text = $text;
	$this->notification = $notification;
  }
 
  public function  __call($method, $parameters)
  {
	if(method_exists($this->notification, $method))
	{
	  return call_user_func_array(array($this->notification, $method), $parameters);
	}
  }
 
  public function  __clone()
  {
	$this->notification = clone $this->notification;
  }
 
}
 
$tweet1 = new Tweet(123, 'Hello world', new Notification);
$tweet2 = clone $tweet1;
 
$tweet1->markAsRead();
var_dump($tweet1->isRead()); // true
var_dump($tweet2->isRead()); // false
```

#### Вызов обьекта как функции

Магический метод __invoke() позволяет определить логику работы обьекта, при попытке обратиться к обьекту как к функции.

```php
class User {
 
  protected $name;
  protected $timeline = array();
 
  public function __construct($name)
  {
	$this->name = $name;
  }
 
  public function addTweet(Tweet $tweet)
  {
	$this->timeline[] = $tweet;
  }
 
}
 
class Tweet {
 
  protected $id;
  protected $text;
  protected $read;
 
  public function __construct($id, $text)
  {
	$this->id = $id;
	$this->text = $text;
	$this->read = false;
  }
 
  public function __invoke($user)
  {
	$user->addTweet($this);
	return $user;
  }
 
}
 
$users = array(new User('Ev'), new User('Jack'), new User('Biz'));
$tweet = new Tweet(123, 'Hello world');
$users = array_map($tweet, $users);
 
var_dump($users);
```

В данном примере я применяю обьект $tweet, как callback-функцию, ко всем значениям массива $users. В данном примере, мы добавим твит каждому пользователю. Согласен, данный пример является немного искусственным, однако я уверен, что вы действительно найдете применение этому методу.

### Заключение

Как вы могли уже убедиться, PHP использует магические методы для реагирования на те или иные действия с методами или свойствами обьекта. Каждый из данных методов срабатывает автоматически, вы просто определяете что должно произойти, а об остальном позаботиться PHP.

В течении довольно длительного времени я не понимал истинного значения магических методов. Я думал, что они нужны, лишь для того чтобы делать какие-либо интересные вещи с обьектами. И когда я, наконец, понял их истинное предназначение, я смог писать более мощные обьекты в рамках более серьезных приложений.

Надеюсь, что в каждом из примеров, представленных в этом руководстве, я смог показать как магические методы могут помочь в повседневных задачах. И я буду не первым кто согласиться, что когда вам обьясняют какой-либо материал, но не обьясняют его практическое применение это реально раздражает.

Автор: Philip Brown

Оригинал: [culttt.com/2014/04/16/php-magic-methods](http://culttt.com/2014/04/16/php-magic-methods/)

Благодарности: werdender, HighQuality

P.S. Простите, знаю что перевод в некоторых местах довольно корявый. Если вы знаете как это звучало бы лучше — напишите мне, я попытаюсь это исправить.
