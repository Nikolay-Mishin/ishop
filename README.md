# ishop - part 2
# Часть 2. Написание пользовательской части CMS интернет-магазина

## ДЗ 2-4 - рассчитать размер скидки программно (при наличии старой цены)
### app\views\Main\index.php (line 78)

## ДЗ 2-6 - делать не запрос к БД, а выбирать валюту из контейнера (реестра)
### app\controllers\CurrencyController (line 15)

## ДЗ 2-7 - сделать функцию округления при пересчете цены
### app\views\Main\index.php (line 71, 74)

## ДЗ 2-15 - ссылка для просмотра всех просмотренных товаров
### app\controllers\ProductController (line 39)

## ДЗ 2-17 - модификации товара (цвет + размер, обновлять старую цену вместе с базовой (старые цены для модификаций излишне))
### app\controllers\ProductController (line 54)
### app\views\Product\view.php (line 66, 75)
* цена может отличать и от цвета и от размера
* можно сделать что-то вроде зависимых списков - при выборе 1 подгружить что-то другое (и наоборот)
* также учитывать, что 1 цвет может быть все цвета, а другой цвет - не все (часть списка)

## ДЗ 2-22 - в корзине реализовать увеличение и уменьшение количества по каждой позиции
### app\controllers\CartController
### app\models\Cart
### public\js\main.js

# Исключения - throw new \Exception('Страница не найдена', 404);
## https://www.php.net/manual/ru/language.exceptions.php

# htmlspecialchars() является подмножеством htmlentities().

## В то время как htmlentities преобразует «все применимые символы в HTML-объекты», htmlspecialchars() преобразует только символы ниже:
* ‘&’ (Амперсанд) становится ‘&amp;’
* ‘ ” ‘ (Двойная кавычка) становится ‘ &quot; ’, когда ENT_NOQUOTES не установлен.
* « ‘ » (Одинарная кавычка) становится ‘ ' ’ (или & apos) только в том случае, если установлен ENT_QUOTES.
* ‘>’ (Больше чем) становится ‘& gt;’

## Обе функции используются для «вывода», чтобы обезопасить веб-страницу от атак с использованием межсайтовых сценариев. Однако в книге Essential PHP Security говорится…
* «Htmlentities() - лучшая экранирующая функция для экранирования данных, отправляемых клиенту».
* Используйте флаг ENT_QUOTES и кодировку UTF-8, как ниже в примере
* htmlentities($userdata, ENT_QUOTES, 'UTF-8');
* Флаг ENT_QUOTES указывает ему преобразовывать как двойные, так и одинарные кавычки.
* И на заметку, параметры двух функций идентичны.

## htmlspecialchars:

1. Если нет необходимости кодировать все символы, имеющие свои эквиваленты HTML.
* Если вы знаете, что кодировка страницы соответствует текстовым специальным символам, зачем использовать htmlentities? htmlspecialchars является очень простым, и выдает меньше кода для отправки клиенту. Например:

```php
echo htmlentities('<Il était une fois un être>.');
// Output: &lt;Il &eacute;tait une fois un &ecirc;tre&gt;.
//                ^^^^^^^^                 ^^^^^^^
```

```php
echo htmlspecialchars('<Il était une fois un être>.');
// Output: &lt;Il était une fois un être&gt;.
//                ^                 ^
```

* Второй вариант короче и не вызывает проблем, если установлена ​​кодировка ISO-8859-1.

2. Когда данные будут обрабатываться не только через браузер (чтобы избежать декодирования HTML-объектов),

3. Если вывод XML (см. ответ Artefacto).

## Потому что:

1. Иногда вы пишете XML-данные, и вы не можете использовать HTML-объекты в XML файле.
* Потому что htmlentities заменяет больше символов, чем htmlspecialchars. Это необязательно, делает PHP скрипт менее эффективным, а полученный HTML-код менее читабельным.
2. htmlentities необходимо, только если ваши страницы используют кодировки, такие как ASCII или LATIN-1 вместо UTF-8, и вы обрабатываете данные с кодировкой, отличной от страницы.

## Это кодируется htmlentities.

```php
implode( "\t", array_values( get_html_translation_table( HTML_ENTITIES ) ) ):

"& <>
¢ ¤ ¤ ¦ ¦ ¦ ¨ ª ± ± ± ´ ± ± ± µ º µ µ ½ ½ ½ À À À À À Ã Ã Å Å É É Ì Í Í Î Î Î Ð Î Î Ð Ð Ñ Ñ Ð Ð Ð Ð Ð Ð × Õ Ö ×
Ù Ú Û Û Û Û ß ß ß ß ã ç ç ç ç ç ë ë ì ì ì ï ï ò ò õ õ ü û ü œ Š Š Š Š Š Š Š Š Š Š Š Š Š Š Š Š Š Š Š Š Š Š Š Š Š
Š Š Š Š Š Š Š Š Š Š Š Š Š Š Š Š Š Š Š Š Š Š Š Š Š. Α Β Γ Δ Ε Ζ Η Θ Ι Λ Λ Μ Ν Ξ Ο Π Σ Σ Τ Υ Φ β Ω Ψ β α β γ γ γ
β η η θ ι ι λ μ μ ω ϑ ϒ ϖ ‌ ‍ - - - - „„ • • ‹‹ ‹‹ ‹‹ ‹‹ ℵ ℵ ℵ ℵ ⇒ ⇒ ⇒ ⇒ ⇒ ⇒ ⇒ ⇒ ⇒ ⇒ ∉ ∉ ∉ ∉ ∑ ∏ ∑ - ∗ √ ∞
∞ ∧ ∩ ∩ ∪ ∪ ∴ ≈ ≈ ≈ ≡ ≤ ≤ ≥ ≥ ⊄ ⊆ ⊇ ⊥ ⋅ ♦ ♦ ♦ ♦ ♦ ♦ ♦
```

## Это кодируется с помощью htmlspecialchars.
```php
implode( "\t", array_values( get_html_translation_table( HTML_SPECIALCHARS ) ) ):

"& <>
```

# Valitron\Validator
### https://github.com/vlucas/valitron

## Встроенные правила проверки
* required - Поле, обязательное для заполнения
* requiredWith - Поле обязательно для заполнения, если есть другие поля
* requiredWithout - Поле обязательно для заполнения, если нет других полей
* equals - Поле должно соответствовать другому полю (электронная почта / подтверждение пароля)
* different - Поле должно отличаться от другого поля
* accepted - Флажок или Радио должны быть приняты (да, вкл, 1, правда)
* numeric - Должен быть числовым
* integer - Должно быть целым числом
* boolean - Должно быть логическим
* array - должен быть массив
* length - Строка должна быть определенной длины
* lengthBetween - Строка должна быть между заданными длинами
* lengthMin - Строка должна быть больше указанной длины
* lengthMax - Строка должна быть меньше заданной длины
* min - минимум
* max - максимум
* listContains- Выполняет проверку in_array для заданных значений массива (наоборот in)
* in - выполняет проверку in_array для заданных значений массива
* notIn- Отрицание inправила (не в массиве значений)
* ip - Действительный IP-адрес
* ipv4 - Действительный IP v4-адрес
* ipv6 - Действительный IP-адрес v6
* email - Действующий электронный адрес
* emailDNS - Действительный адрес электронной почты с активной записью DNS
* url - Действительный URL
* urlActive - Действительный URL с активной записью DNS
* alpha - только буквенные символы
* alphaNum - Буквенные и числовые символы только
* ascii - только символы ASCII
* slug - символы слагов URL (az, 0-9, -, _)
* regex - Поле соответствует заданному шаблону регулярных выражений
* date - Поле является действительной датой
* dateFormat - Поле является действительной датой в указанном формате
* dateBefore - Поле является действительной датой и предшествует указанной дате
* dateAfter - Поле является действительной датой и находится после указанной даты
* contains - Поле является строкой и содержит данную строку
* subset - Поле - это массив или скаляр, и все элементы содержатся в данном массиве.
* containsUnique - Поле является массивом и содержит уникальные значения
* creditCard - Поле является действительным номером кредитной карты
* instanceOf - Поле содержит экземпляр данного класса
* optional- Значение не нужно включать в массив данных. Однако, если это так, он должен пройти проверку.
* arrayHasKeys - Поле является массивом и содержит все указанные ключи.

## набор правил для валидации
### Пример проверки формы
```php
public $rules = [
    // обязательные поля - правило проверяет , если поле существует в массиве данных, и не является нулевым или пустой строкой
    'required' => [
        ['login'],
        ['password'],
        ['name'],
        ['email'],
        ['address'],
    ],
    // поле email - проверяет , что поле является действительным адресом электронной почты
    'email' => [
        ['email'],
    ],
    // минимальная длина для поля
    'lengthMin' => [
        ['password', 6],
    ]
]
```

### Проверка полей
```php
public $rules = [
    // если два поля равны в массиве данных, а также о том , что второе поле не является пустым
    // ['password' => 'youshouldnotseethis', 'confirmPassword' => 'youshouldnotseethis']
    'equals' => [
        ['password', 'confirmPassword']
    ],
    // два поля не совпадают, или разные, в массиве данных и о том , что второе поле не является пустым
    // ['username' => 'spiderman', 'password' => 'Gr33nG0Blin']
    'different' => [
        ['username', 'password']
    ]
]
```

### Проверка значений
```php
public $rules = [
    // поле соответствует заданному шаблону регулярного выражения. (Это регулярное выражение проверяет, что строка является буквенно-цифровой от 5 до 10 символов)
    // ['username' => 'Batman123']
    'regex' => [
        ['username', '/^[a-zA-Z0-9]{5,10}$/']
    ],
    // является ли поле точно заданной длины , и что поле является действительной строкой
    'length' => [
        ['username', 10]
    ],
    // если поле между заданной длиной Тангой и что полем является действительной строкой
    'lengthBetween' => [
        ['username', 1, 10]
    ],
    // если поле по меньшей мере , заданное значение , и что при условии , значение числовое
    // ['age' => 28]
    'min' => [
        ['age', 18]
    ],
    // поле содержит только символы слизняка URL (Az, 0-9, -, _)
    // ['username' => 'L337-H4ckZ0rz_123']
    'slug' => [
        ['username']
    ],
    // поле только алфавитные символы
    // ['username' => 'batman']
    'alpha' => [
        ['username']
    ],
    // поле содержит только буквенные или цифровые символы
    // ['username' => 'batman123']
    'alphaNum' => [
        ['username']
    ]
]
```

### Проверка типов
```php
public $rules = [
    // является ли поле номер. Это аналог функции is_numeric () в php
    // ['amount' => 3.14]
    'numeric' => [
        ['amount']
    ],
    // если поле является целым числом
    // ['age' => '27']
    'integer' => [
        ['age']
    ],
    // Обратите внимание, что необязательный логический флаг для строгого режима позволит указывать целые числа как отрицательные значения. Таким образом, следующее правило оценивается как истинное
    // ['age' => '-27']
    'integer' => [
        ['age', true]
    ],
    // если поле является логическим. Это аналог функции is_bool () в php
    // ['remember_me' => true]
    'boolean' => [
        ['remember_me']
    ],
    // если поле является массивом. Это аналог функции is_array () в php
    //['user_notifications' => ['bulletin_notifications' => true, 'marketing_notifications' => false, 'message_notification' => true]]
    'array' => [
        ['user_notifications']
    ]
]
```

### Проверка даты
```php
public $rules = [
    // поле является действительным \ DateTime объекта или , если строка может быть преобразован в метку времени UNIX с помощью StrToTime ()
    // ['created_at' => '2018-10-13']
    'date' => [
        ['created_at']
    ],
    // прилагаемое поле является действительной датой в заданном формате дата
    'dateFormat' => [
        ['created_at', 'Y-m-d']
    ],
    // прилагаемое поле является действительной датой до указанной даты
    // ['created_at' => '2018-09-01']
    'dateBefore' => [
        ['created_at', '2018-10-13']
    ],
    // прилагаемое поле является действительной датой после указанной даты
    'dateAfter' => [
        ['created_at', '2018-01-01']
    ]
]
```

### Проверка URL
```php
public $rules = [
    // поле является допустимой URL
    // ['website' => 'https://example.com/contact']
    'url' => [
        ['website']
    ]
]
```

### Проверка IP
```php
public $rules = [
    // поле является действительным адресом IP. Это включает в себя IPv4, IPv6, частные и зарезервированные диапазоны
    // ['user_ip' => '127.0.0.1']
    'ip' => [
        ['user_ip']
    ]
]
```