### Подводный камень в foreach($items as &$item)
##### #PHP

Многие любят писать такие конструкции в том или ином виде, каждый сталкивался:

```php
foreach ($items as &$item) {
    $item += 2;
}
```

Но не многие подозревают о том, какая опасность тут скрывается.
Рассмотрим пример.

Вася Пупкин взял массив, прошелся по нему, увеличив на два все элементы:

```php
$items = array(
    'a' => 10,
    'b' => 20,
    'c' => 30,
);

foreach ($items as &$item) {
    $item += 2;
}

print_r($items);
```

Посмотрел дамп, увидел что задача решена, и ушел довольный:

```php
Array
(
    [a] => 12
    [b] => 22
    [c] => 32
)
```

Спустя некоторое время, Петрович решил дополнить этот участок кода другим перебором, дописав ниже:

```php
$newitems = array(
    'a' => 10,
    'b' => 20,
    'c' => 30,
);

foreach ($newitems as $key=>$item) {
    $newitems[$key] += 5;
}

print_r($newitems);
```

Посмотрел, что его задача тоже решена, и с чувством выполненного долга закрыл файл:

```php
Array
(
    [a] => 15
    [b] => 25
    [c] => 35
)
```

Спустя какое-то время, стали вылезать необъяснимые баги. Почему?
Сделаем в конце кода var_dump($items):

```php
array(3) {
  ["a"]=>
  int(12)
  ["b"]=>
  int(22)
  ["c"]=>
  &int(30)
}
```

30! Вася Пупкин клянётся, что проверял. Почему было 32, а после кода Петровича 30?

##### Причина кроется в амперсанде.

Он сообщает, что на отмеченные данные ссылается кто-то ещё. Уходя, Вася не подтёр за собой временную переменную, которую использовал для перебора ($item). Переменная использовалась с разрешением на изменение источника ("&"), которое также называют «присваиванием по ссылке». Он был уверен, что переменная будет использоваться только внутри цикла. Петрович, используя переменную с таким же именем, в ходе своего перебора, менял её значение, и каждый раз менялось то место, где эта переменная хранилась. А хранилась она там же, где последний элемент массива Пупкина.

Конечно, в случай в статье утрирован. На практике такие связи могут быть очень сложными, особенно если проект недорогой, и в нём участвуют недостаточно опытные и разрозненные веб-разработчики.

##### Как можно с этим оброться?
* Уничтожать временные переменные после использования, особенно если они имеют какие-то связи с используемыми данными:

```php
foreach ($items as &$item) $item += 2;
unset($item);
```

* Быть осторожнее с переменными, которые уже кем-то использовались.
* Инкапсулировать свои действия в отдельные функции, методы или пространства имён.
* Использовать var_dump, вместо print_r, и обращать внимание на амперсанд. Чтобы дампить в файл, а не в браузер, альтернативой print_r($var,true) будет такая конструкция:

```php
function dump() {
    ob_start();
    foreach(func_get_args() as $var) var_dump($var);
    return ob_get_clean();
}
```

В заключение скажу, что баги, связанные со ссылками, могут быть не только в foreach. И все они когда-то обсуждались. Однако, этот случай, судя по моему опыту, так распространён на практике, что заслуживает отдельного внимания.



### Клонирование объектов

Создание копии объекта с абсолютно идентичными свойствами не всегда является приемлемым вариантом. Хорошим примером необходимости копирования конструкторов может послужить ситуация, когда у вас есть объект, представляющий собой окно GTK и содержащий ресурс-идентификатор этого окна; когда вы создаете копию этого объекта, вам может понадобиться, чтобы копия объекта содержала ресурс-идентификатор нового окна. Другим примером может послужить ситуация, когда ваш объект содержит ссылку на какой-либо другой используемый объект и, когда вы создаёте копию родительского объекта, вам нужно также создать новый экземпляр этого другого объекта, так, чтобы копия объекта-контейнера содержала собственный отдельный экземпляр содержащегося объекта.

Копия объекта создается с использованием ключевого слова clone (который вызывает метод `__clone()` объекта, если это возможно). Вызов метода `__clone()` не может быть осуществлён напрямую.

`$copy_of_object = clone $object;`

При клонировании объекта, PHP выполняет неполную копию всех свойств объекта. Любые свойства, являющиеся ссылками на другие переменные, останутся ссылками.

```php
__clone ( void ) : void
```

После завершения клонирования, если метод `__clone()` определен, тогда будет вызываться метод `__clone()` вновь созданного объекта, для возможного изменения всех необходимых свойств.

##### Пример #1 Клонирование объекта

```php
class SubObject
{
    static $instances = 0;
    public $instance;

    public function __construct() {
        $this->instance = ++self::$instances;
    }

    public function __clone() {
        $this->instance = ++self::$instances;
    }
}

class MyCloneable
{
    public $object1;
    public $object2;

    function __clone()
    {
        // Принудительно копируем this->object, иначе
        // он будет указывать на один и тот же объект.
        $this->object1 = clone $this->object1;
    }
}

$obj = new MyCloneable();

$obj->object1 = new SubObject();
$obj->object2 = new SubObject();

$obj2 = clone $obj;


print("Оригинальный объект:\n");
print_r($obj);

print("Клонированный объект:\n");
print_r($obj2);
```

###### Результат выполнения данного примера:

```
Оригинальный объект:

MyCloneable Object
(
    [object1] => SubObject Object
        (
            [instance] => 1
        )

    [object2] => SubObject Object
        (
            [instance] => 2
        )

)

Клонированный объект:

MyCloneable Object
(
    [object1] => SubObject Object
        (
            [instance] => 3
        )

    [object2] => SubObject Object
        (
            [instance] => 2
        )

)
```

В PHP 7.0.0 введена возможность обращения к свойствам/методам только что склонированного объекта:

##### Пример #2 Доступ к только что склонированному объекту

```php
$dateTime = new DateTime();
echo (clone $dateTime)->format('Y');
```

###### Результатом выполнения данного примера будет что-то подобное:

```
2016
```
