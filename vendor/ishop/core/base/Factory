<?php

namespace ishop\base;

/**
* Базовая Фабрика, которую будут наследовать все Фабрики
*
* @author [x26]VOLAND
*/
abstract class Factory {

private static string $postfix = '';
private static string $extends = '';
private static string $implements = '';
private static string $context = '';

	/**
	* Создаёт экземпляр класса заданного типа.
	*
	* @param string $type Тип коллекции
	* @return object
	*/
	public static function create(string|object $type, object ...$args): object {
		$class = self::createClass($type);
		if (is_object($type)) array_unshift($args, $type);
		return new $class($class);
	}

	/**
	* Создаёт класс с именем $class
	*
	* @param string $class Имя класса
	* @return void
	*/
	private static function createClass(string|object $class): void {
		extract(self::parseNamespace($class.self::$postfix));
		if (!class_exists($class)) {
                        $namespace = $namespace ? "namespace $namespace; " : $namespace;
                        $extends = self::$extends ? "extends ".self::$extends : self::$extends;
                        $implements = self::$implements ? "implements ".self::$implements : self::$implements;
                        debug("$namespace class $class $extends $implements {".self::$context."}");
		        eval("$namespace class $class $extends $implements {".self::$context."}");
		}
		//debug(getClassName("$namespace\\$class"));
                return "$namespace\\$class".self::$postfix;
	}

	public static function parseNamespace(string|object $namespace): array {
		$namespace = is_object($namespace) ? get_class($namespace) : $namespace;
                preg_match('/(.*)(\W)(\w+)$/', $namespace, $match);
		$class = $match[3] ?? $namespace;
		$namespace = $match[1] ?? '';
		return compact('class', 'namespace');
	}

}
